#summary Description of the application layers.

== Introduction ==

SocialConnect is separated in two layers:


The Model layer contains the models used to store remote platforms information and users's account on those platforms. It also deals with the whole authentification process. The Model layer validates any API request and send it to the Proxy layer who sends the request to the remote API.


== Platforms and Accounts ==
The supported platforms are added through the Django admin. The current release has been tested with Facebook, MySpace and Partuza. The information for those platforms can be found [PlatformFixtures here].

For a user that send a query to a remote platform, SocialConnect creates a local `PlatformAccount` to store the id of the user on the remote platform as well as his session information. The only data from the remote platform that is automatically stored is the user id.


== Make queries ==
To make queries to an API, a view needs two things. First it needs a decorator to deal with the possible exception raised by SocialConnect. Second, it needs to set a social context to make an API call.

This is an example of a view that get the current user profile from a remote platform:
{{{
@login_required
@exception_handler
def get_profile(request, platform_id):
	'''
	View that get the user profile and display it without formatting.
	'''
	
	# get the social context
	social_context = SocialContext.get_or_create_social_context(request, platform_id)
	
	# get the profile from the remote platform
	profile_infos = social_context.get_profile(request, 'get_profile', platform_id)

	# get the remote platform
	platform = Platform.objects.get(id=platform_id)

	
	return direct_to_template(request, 'yasn/poc/profile.html', {'profile': profile_infos, 'platform_name': platform.name})
}}}

*Social Context*: The Social Context is the interface of SocialConnect: it contains the core logic of the application. Every call to a remote API needs one. The Social Context is a Python object that provide the methods to call a remote API and handle the API authorization.  

The Social Context acts like a singleton because each user has his own instance. It contains a communication object that is an instance of the communication library (pyFacebook or home-made OpenSocial) with a remote platform. The Social Context is responsible to validate this communication object before executing the API query. (See [AuthentificationProcess authorization page in the wiki] for more details). If the call is authorized, it's send to the Proxy Layer that will execute the call to the remote platform.

*Exception decorator*: The `exception_handler` decorator is necessary to catch any exception  `social_context.get_profile(request, 'get_profile', platform_id)` might raise. This could be related to an authentification issue and then the decorator will redirect the user to the authorization page of the remote platform. TODO: Complete..
#summary Description of the application layers.

== Introduction ==

SocialConnect is separated in two layers:


The Model layer contains the models for remote platforms, accounts and deals with authentification. When the Model layer validates a request it send it to the Proxy layer whow send the request to the remote API.


== Platforms and Accounts ==
The supported platforms are added through the Django admin. The current release comes with support for Facebook, MySpace and Partuza. The application key and secret are empty and must be completed.


== Make queries ==
To make queries to an API, a view needs two things. First it needs a decorator to deal with the possible exception raise by SocialConnect. Second, it needs to set a social context to make an API call.

This is an example of a view that get the current user profile from a remote platform:
{{{
@login_required
@exception_handler
def get_profile(request, platform_id):
	'''
	View that get the user profile and display it without formatting.
	'''
	
	# get the social context
	social_context = SocialContext.get_or_create_social_context(request, platform_id)
	
	# get the profile from the remote platform
	profile_infos = social_context.get_profile(request, 'get_profile', platform_id)

	# get the remote platform
	platform = Platform.objects.get(id=platform_id)

	
	return direct_to_template(request, 'yasn/poc/profile.html', {'profile': profile_infos, 'platform_name': platform.name})
}}}

*Social Context*: The Social Context is the interface of SocialConnect: it contains the core logic of the application. Every call to a remote API needs one. The Social Context is a Python object that provide the methods to call a remote API and handle the API authorization.  

The Social Context acts like a singleton because each user has his own instance. It contains a communication object that is an instance of the communication library (pyFacebook or home-made OpenSocial) with a remote platform. The Social Context is responsible to validate this communication object before executing the API query. If the context is freshly created, it doesn't have a communication object yet. So the communication object validation will fail. The validation will first try to create a new object using the session information from a previous request stored in the database. If no information is available, the Social Context will raise a `RedirectException`. The `exception_handler` decorator will catch it and redirect the user to the remote platform to get the necessary information to build a new communication object.

The process is the following:
[http://socialconnect.googlecode.com/files/comObject-valdiation.png]

If it can't, it raise an exception. To be valid, the communication object needs to have an authorized session to the remote platform. For Facebook, the object has a token that it used to get a session key that is send with the request. For OpenSocial, the object has an access token that might directly be used to query the platform. In both cases, the session has a limited validity in time. So the Social Context need to check if the session is still valid and possibly request a new session from the platform. This is addressed by a redirection of the user to the remote platform to obtain a fresh token.



If the error is related to authorization only, the `exception_handler` decorator will catch the exception and redirect the user to the remote platform for authorization. The user will then come back to SocialConnect views that will store the information authorization from the platform.
 


*Exception decorator*: The `exception_handler` decorator is necessary to catch any exception  `social_context.get_profile(request, 'get_profile', platform_id)` might raise. This could be related to an authentification issue, then the decorator will take the necessary steps to authorize the call. A redirection to the remote platform might be necessary. (See [AuthentificationProcess authorization page in the wiki] for more details).